# 隐式类型转换

## 前言

在javascript中，除了显示的转换数据类型如调用 Number() Boolean() String()等方法外，有时候一些写法能够直接起到隐式类型转换，例如我们常写的`1 + '2' === '12'`这其中 `+`的运算就发生了一个隐式类型转换。除此之外，再思考一下下面的答案。

``` javascript
[] + [];
{} + {};
[] + {};
{} + [];

1 == true;
0 == '';
null == undefined;


const a = {
  i: 1,
  toString: function () {
    return a.i++;
  }
}
if (a == 1 && a == 2 && a == 3) {
  console.log('hello world!'); // 输出hello world
}

```

## 隐式转换类型

### ToPrimitive(input, PreferredType?: 'Number' | 'String')

PreferredType只是一个转换标志，实际最后的转换结果并不一定就是该类型，但是转换的结果一定要是个原始值。（否则会报错）, 在javascript中，默认设置为 Number ，除了 input 为 Date 类型，则设置为String。

PreferredType为Number时：
+ 输入值已经是原始值，返回它。
+ 调用输入值的 valueOf 方法，如果结果是原始值，返回它。
+ 调用输入值的 toString 方法，如果结果是原始值，返回它。
+ 最后的结果还不是原始值，抛出TypeError异常。


PreferredType为String时：
+ 输入值已经是原始值，返回它。
+ 调用输入值的 toString 方法，如果结果是原始值，返回它。
+ 调用输入值的 valueOf 方法，如果结果是原始值，返回它。
+ 最后的结果还不是原始值，抛出TypeError异常。

### 常见对象的valueO, toString方法结果
> valueOf 和 toString 方法一定都有实现，有些类型自己的原型有实现，最后顶层原型 Object.prototype 都有这两个方法的实现。

先看 valueOf 方法：

+ Number, String, Boolean这三种基本类型的构造函数，通过 valueOf 转换后会变成对应的原始值。Date类型调用valueOf方法返回时间戳。

``` javascript
var num = new Number('123');
num.valueOf(); // 123

var str = new String('12df');
str.valueOf(); // '12df'

var bool = new Boolean('fd');
bool.valueOf(); // true

var date = new Date();
date.valueOf(); // 1622535486108

```

+ 其它类型，调用valueOf都返回this，即自己本身。

``` javascript
var arr = [1, 2, 3];
arr.valueOf() === arr; // true
var obj = {a: 1};
obj.valueOf() === obj; // true
var sym = Symbol();
sym.valueOf() === sym; // true
var bigint = 1n;
bigint.valueOf() === bigint; // true
```

再看看 toString 方法，下面是一些例子，都是一股脑的转成字符串。

``` javascript
var num = 1;
var num1 = new Number('123as');
var bool = true;
var str = 'bowlofnoodles';
var sym = Symbol();
var bigint = 1n;

var arr = [1, 2, 3];
var obj = {};
var date = new Date();
var func = function () {};
var reg = /reg/g;

// 注 都是返回字符串形式
console.log(
  num.toString(), // 1
  num1.toString(), // NaN
  bool.toString(), // true
  str.toString(), // bowlofnoodles
  sym.toString(), // 'Symbol()'
  bigint.toString(), // 1
  arr.toString(), // [1,2,3]
  obj.toString(), // [object Object]
  date.toString(), // Tue Jun 01 2021 16:26:10 GMT+0800 (中国标准时间)
  func.toString(), // function func() {}
  reg.toString() // /reg/g
);


```

### ToNumber

就是显示类型转换Number()的调用结果。
+ undefined -> NaN
+ null -> 0
+ 布尔值 -> true为1， false为0
+ 字符串 -> 纯数字的字符串解析为对应数字，否则为NaN。例如'123' -> 123，'qwe123' -> NaN
+ 数字 -> 该数字
+ 对象 -> 先进行ToPrimive(input, Number)转化到原始值，在进行ToNumber转化为数字
+ 其它不包含在上列的，一般都转化为NaN

### ToString

就是显示类型转换String()的调用结果。
+ undefined -> 'undefined'
+ null -> 'null'
+ 布尔值 -> true为'true'， false为'false'
+ 字符串 -> 该字符串
+ 数字 -> 1 -> '1'
+ 对象 -> 先进行ToPrimive(input, String)转化到原始值，在进行ToString转化为字符串
+ 其它不包含在上列的，一般都转化为对应的字符串，例如NaN -> 'NaN'

## + 和 == 

### + 运算符

+ 运算符的左右两边存在不为原始类型的值，则都调用ToPrimive()转换为原型值
+ 运算符左右两边都为原始值之后，如果存在一个是字符串，则调用ToString()，双方转换为字符串，然后作字符串拼接。
+ 运算符左右两边都为原始值之后，如果两边都不是字符串，则双方调用ToNumber()转化为数字后进行正常的加法运算。

现在我们来回一下上面的答案：

+ [] + []：都不是原始值，转换为原始值，默认ToPrimitive(input, Number)，则为 '' + '' = '';
+ {} + {}: 都不是原始值，转换为原始值，默认ToPrimitive(input, Number)，则为 '[object Object]' + '[object Object]' = '\[object Object\]\[object Object\]';
+ [] + {}: 都不是原始值，转换为原始值，...，则为 '' + '[object Object]' = '[object Object]';
+ {} + []: 注意这里跟[] + {}本质应该一样，但是{}放前面被识别成了代码段，所以实际相同于 +[]，相当于Number(\[\])的操作，得到0。如果我们希望得到正确的结果，可以这样写({}) + [] => '[object Object]'
